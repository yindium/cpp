# Introduction to C++
Each individual 0 or 1 is called a binary digit, or bit for short. The number of bits that make up a single command varies -- for example, some CPUs process instructions that are always 32 bits long, whereas some other CPUs (such as the x86/x64 family, which you may be using) have instructions that can be a variable length.

Each set of binary digits is interpreted by the CPU into a command to do a very specific job.

----------

`1972` Dennis Ritchie saw C at Bell Labs.

`1978`
K&R standard was adopted at that time even though it was informal specification for the language.
They'd stick to the recommendations of K&R because most of the compilers would implement that standard.

----------

`1989`
American National Standards Institute (ANSI) finally established a formal standard for C known as C89 or ANSI C.
International Organization for Standardization (ISO) adopted ANSI C with minor modifications known to be as C90.
Compilers became compliant, desiring maximum portability were coded to this standard. (because duh they standardized for a reason)

----------

`1979` that's like 7 years after C. Bjarne Stroupstrup made extension of C. (fun fact: the first name of the this was 'C with Classes' later in `1984`, the name we know it as today was given)
People thought of it more like a superset but it's not technically true. *C99 had some features that did not make it to C++*
C++ was standardized in 1998 by the ISO committee (this means the ISO standards committee approved a document describing the C++ language, to help ensure all compilers adhere to the same set of standards). A minor update to the language was released in 2003 (called C++03).
Five major updates to the C++ language (**C++11, C++14, C++17, C++20, and C++23**) have been made since then, each adding additional functionality. C++11 in particular added a huge number of new capabilities, and is widely considered to be the new baseline version of the language.
Each new formal release of the language is called a language standard (or language specification). A new one typically will appear every 3 years or so.

> **Define > Design > Implement > Compile > Link > Test > Debug <**
- we define the problem first! without knowing what we specifically are solving is meaningless.
- then we design the best solution we can come up with!
- then implement the solution in our programs using the usable and pre-defined instructions (that's what sets us apart) 
- compile it! and it links other object files along with our source
- test it! if fails, then sit with a calm mind to lose its calmness debugging (that's what will set YOU apart from others ho leave their solutions with bugs and forget the forest they imagined later because of the bugs)


### Compiling
1. Compiler checks C++ source code to make sure it follows the rules of C++ (of that specific standard).
2. It translates C++ code into Machine language instructions.
> These instructions are stored in an intermediate file called an <u>object file<u/>. The object file also contains metadata that is required or useful in subsequent steps.

After the compiler has successfully finished, another program called the linker kicks in. The linker’s job is to combine all of the object files and produce the desired output file (typically an executable file). This process is called linking.

First, the linker reads in each of the object files generated by the compiler and makes sure they are valid.

Second, the linker ensures all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in a different .cpp file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.

Third, the linker also is capable of linking library files. A library file is a collection of pre-compiled code that has been “packaged up” for reuse in other programs.

C++ comes with an extensive library called the C++ Standard Library (usually shortened to standard library) that provides a set of useful capabilities for use in your programs. One of the most commonly used parts of the C++ standard library is the iostream library, which contains functionality for printing text on a monitor and getting keyboard input from a user. Almost every C++ program written utilizes the standard library in some form, so it’s very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn’t something you need to worry about.

----------
#### Something about errors in Compilers
By default, most compilers will only generate warnings about the most obvious issues. However, you can request your compiler be more assertive about providing warnings for things it finds strange.

For GCC/G++ users
Add the following flags to your command line: `-Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion`
Adding them together also triggers the `-Wunused-parameter` also though that as it is named checks for unused variables and parameters.
- Adding `-Werror` will make the compiler forcefully treat warnings as errors. (either best practice to maintain good code base or masochistic behavior)
- `-Wall` will enable all the common compiler warnings.
- `-Wextra` some extra warnings.
- `-w` inhibit all warning messages.
- `-Wfatal-errors` stops compiling after first error.
I mean don't be judging for being this nerdy about errors, syntax errors are treated as errors too.


| Code name | Finalized name |
| --------- | -------------- |
| C++0x     | C++11          | > it was orginally expected to be finalized before 2010 thus the codename has `0x`
| C++1y     | C++14          |
| C++1z     | C++17          |
| C++2a     | C++20          |
| C++2b     | C++23          |
| C++2c     | C++26          | > [!NOTE] at the time of writing this, it is not finalized yet.

There are other arguments that can be added when calling the compiler such as,
- `-std=[version]` => makes the compiler use a specific standardization instead of the default (generally 2 standards back to ensure no issues that aren't resolved due to a new release. e.g. GCC currently uses C++17 by default.)
The [version] can be either the codename or finalized name.
- `-O[n]` => controls optimization levels.
[n] - level of optimization.
